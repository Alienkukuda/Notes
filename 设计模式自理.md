本文是针对spring中涉及到的设计模式记下自己的理解，顺便回顾设计模式的知识点，可能包括sping的部分源码。

首先是工厂设计模式

Spring有**BeanFactory**和**ApplicationContext**两种类型容器，可以通过这两种方式来创建bean对象，其中就是涉及到了工厂模式，工厂模式比较好理解，可以分为三种：简单工厂模式、工厂方法模式和抽象方法模式。

就拿工厂方法模式举例，其实简单工厂模式不在26种设计模式之中，工厂方法模式只是将简单工厂的一个工厂变为多个工厂，多个工厂实现一个共同接口，直接调用指定的工厂方法创建对象即可，抽象方法在此不做介绍。

观察者模式-spring数据驱动模型。

代理模式

**Spring AOP 就是基于动态代理的**，如果要代理的对象，实现了某个接口，那么Spring AOP会使用**JDK Proxy**，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候Spring AOP会使用**Cglib**，当然也可以使用 AspectJ，Spring AOP 已经集成了AspectJ 。

至于代理模式分为静态代理和动态代理，静态代理比较简单，即再创建一个代理类调用目标方法；动态代理则要实现`InovactionHander`接口，实现`invoke`方法，再在调用方法时生成继承`proxy0`又实现接口的对象。

适配器模式

当你不能调用目标方法，而又不能修改这个方法甚至这个目标类，适配器模式起到的帮助就很大。

springAOP中的适配器模式，`advice`方法适配成`MethodInterceptor`接口(方法拦截器)类型的对象。

springMVC中的适配器模式，通过适配器模式我们将所有的`controller`统一交给`HandlerAdapter`处理，免去了写大量的if-else语句对`controller`进行判断，也更利于扩展新的`controller`类型。

模块方法模式

<img src="/Users/captain/study for myself/Java 笔记/Notes/image/模块方法模式.png" alt="模块方法模式" style="zoom:50%;" />

Spring 中 `jdbcTemplate`、`hibernateTemplate` 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。一般情况下，我们都是使用继承的方式来实现模板模式，但是 Spring 并没有使用这种方式，而是使用Callback 模式与模板方法模式配合，既达到了代码复用的效果，同时增加了灵活性。

单例模式

在我们的系统中，有一些对象其实我们只需要一个，比如说：线程池、缓存、注册表、日志对象等，使用单例模式可以省略创建对象所花费的时间，同时减轻 GC 压力，缩短 GC 停顿时间。

推荐两种创建方式：双重检查模式（DCL）和静态内部类模式

```Java
public class Singleton {  
    private volatile static Singleton singleton;  //1:volatile修饰
    private Singleton (){}  
    public static Singleton getSingleton() {  
    if (singleton == null) {  //2:减少不要同步，优化性能
        synchronized (Singleton.class) {  // 3：同步，线程安全
        if (singleton == null) {  
            singleton = new Singleton();  //4：创建singleton 对象
        }  
        }  
    }  
    return singleton;  
    }  
}
```

1. 延迟初始化。和懒汉模式一致，只有在初次调用静态方法`getSingleton`，才会初始化`signleton`实例。
2. 性能优化。同步会造成性能下降，在同步前通过判读`singleton`是否初始化，减少不必要的同步开销。
3. 线程安全。同步创建Singleton对象，同时注意到静态变量`singleton`使用`volatile`修饰。

其中使用`volatile`是为了防止重排序，多线程情况下获取到未初始化的对象。

```Java
public class Singleton { 
    private Singleton(){
    }
    public static Singleton getSingleton(){  
        return Inner.instance;  
    }  
    private static class Inner {  
        private static final Singleton instance = new Singleton();  
    }  
} 
```

1. 实现代码简洁。
2. 延迟初始化。调用`getSingleton`才初始化`Singleton`对象。
3. 线程安全。JVM在执行类的初始化阶段，会获得一个可以同步多个线程对同一个类的初始化的锁。

静态内部类的方法只有在外部调用的时候才会初始化。