#### Collection和Map接口

这里给出集合的框架图，可以看出Collection的子类是Set、List、Queue、SortedSet。Map是独立的接口。

为了方便梳理结构，先抛开SortedSet，其它三个和Map都是AbstractXXX来实现接口，对应的类再继承AbstractXXX。比较容易想到的是TreeSet、HashSet和ArrayList、LinkedList和四个BlockingQueue和TreeMap、HashMap、ConcurrentMap。接下来也会对这几个做个简单的比较。

hash和link区别是数组和链表，hash和tree区别是一个用hashcode定位，一个是自然排序。

<img src="./image/Java 集合框架图.jpeg" alt="Java 集合框架图" style="zoom: 60%;" />

##### TreeMap

首先是TreeMap，不同于 HashMap，TreeMap并非要覆写 hashCode和 equals方法来达到 Key去重的目的，它根据comparable或comparator进行排序，保证key的有序性。不管1.7和1.8，它是基于红黑树实现的，通过put()和deleteEntry()来实现红黑树的增加和删除。

在此仅阐述put内部分源码，首先是比较部分，如果未调用外部比较器，就用自然排序的Comparable比较，比较完之后 **fixAfterInsertion **方法则是重中之重，用来调整红黑树。

新节点总是黑色的，如果父结点为黑色则不变化，反之进行后续。

1. 父节点为红色，叔叔是红色，则爷爷变为红色，父亲和右叔变为黑色
2. 父节点为红色，叔叔是黑色，新节点为父亲的右子树，先左旋，父结点变为黑色，爷爷变成红色，最后爷爷右旋。
3. 父节点为红色，叔叔是黑色，新节点为父亲的左子树，父结点变为黑色，爷爷变成红色，最后爷爷右旋。

##### HashMap

HashMap已经看了好几遍了，这里确实有必要记一下。

首先是源码部分，**1.7版本**，put -> 获取hash(key) -> 通过返回值&处理获得index -> 遍历判断slot上是否有相同key，有则覆盖 -> addEntry -> resize -> translate -> createEntry（hashmap和concurrenthashmap在jdk1.8将头插入改为尾插入）；**1.8版本**则在putVal方法中modCount++前尾部插入。

**原因**：在jdk1.7中采用头插入法，在扩容时会改变链表中元素原本的顺序，以至于在并发场景下导致链表成环的问题。而在jdk1.8中采用尾插入法，在扩容时会保持链表元素原本的顺序，就不会出现**链表成环**的问题了，个人觉得也没了并发条件下数据被覆盖的情况。

#### B树、B+树、红黑树

##### 红黑树的性质

1. 节点是红色或黑色。
2. 根是黑色。
3. 所有叶子都是黑色（叶子是NIL节点）。
4. 每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）
5. 从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。

##### B、B+树的性质（自己理解）

1. 根节点至少有两个子节点；
2. 每个节点最多有m-1个key值，升序排列，value也按照键值排列（B+ 树可能最多有m个，定义不同）
3. 除根节点外，其他节点至少有m/2个节点。

##### B树和B+树的区别

简要解释:
第一点，B+树中，节点的每一个关键字代表一个子树的最大值，因此**子结点数目等于关键字数目**；第二点，叶子节点包含了全部的数据，并按照顺序排列，B+树使用链表将他们连起来，这样在查询时效率更快。

1.**层级更低(更加矮胖)，IO次数更少**。由于 B+ 树的中间节点不含有实际数据，只有子树的最大数据和子树指针，因此磁盘页中可以容纳更多节点元素，也就是说同样数据情况下，B+ 树会 B 树更加“矮胖”，因此查询效率更快。

2.**每次都需要查询到叶子节点，查询性能稳定**。B树这时就能体现出优势，由于出现频率较高的树，在B树中往往在上层(非叶子结点)，查找到该结点就会成功并结束查询，相对较快。而B+树由于非叶子结点关键字只是代表索引，因此在B+树中，无论查找成功与否，都是走了一条从根到叶子节点的路径。

3.**B+树范围查询更加方便**。 需要查询某个范围内的数据时，由于 B+ 树的叶子节点是一个有序链表，只需在**叶子节点上遍历**即可，不用像 B 树那样挨个**中序遍历**比较大小。

源码顺序：HashMap->ConcurrentHashmap->TreeMap->红黑树部分源码

