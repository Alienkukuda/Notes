[redis掘金笔记](https://juejin.im/post/5ad6e4066fb9a028d82c4b66)


String（字符串）、list（链表）、set（集合）、zset（有序集合）、hash（hash类型）

单线程的IO模型。

数据都是缓存在内存中。

会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，实现了master-slave(主从)同步。

对事务部分支持，一般操作是开始multi开启、入队、exec触发，入队前报错整体回滚，入队后报错部分回滚，所以不支持原子性。

6中淘汰策略，保证热数据，最近最少使用算法。

redis持久化机制：RDB快照和AOF日志。rdb原理是对redis中的数据进行周期的持久化，redis会用fork函数创建子进程，父进程会正常执行客户端发来的请求操作，而子进程会把当前的数据库快照写入到临时文件中，最后替换原有的文件（默认为dump.rdb）；aof模式通过把每条指令**追加**到日志文件中（默认为appendonly.aof文件），当redis重启后，通过回放aof日志文件中的操作来实现数据集的恢复。

持久化能保证重启数据的回复，但是不能保证硬盘损坏的数据丢失，可以通过redis的主从复制和部分复制。具体操作就是从机连接主机，发送sync命令，主机创建进程生成快照，把写命令写进缓存，发送快照，从机解析快照，主机发送命令缓存，从机接收命令并处理。局部复制很简单， 从机会提供 master 的 runid(机器标识，随机生成的一个串) 和 offset（数据偏移量），主服务器每次接收到写命令，处理完成后就发送同样的命令到从服务。

如果需要使用流水线发送大量命令，比较好的做法是将它们按照一个合理的大小分成多个批次，比如使用流水线一次性发送10k个命令，然后读取响应，再发送另外的10k个命令，以此类推，减少与redis服务器的交互次数。

**缓存穿透：**请求去查询一条压根儿数据库中根本就不存在的数据，也就是缓存和数据库都查询不到这条数据，但是请求每次都会打到数据库上面去。

**解决方案：**缓存空值；BloomFilter过滤

**缓存击穿：**大量的请求同时查询一个 key 时，此时这个key正好失效了，就会导致大量的请求都打到数据库上面去。

**解决方案：**在第一个查询数据的请求上使用一个 互斥锁来锁住它

**缓存雪崩：**当某一时刻发生大规模的缓存失效的情况，比如你的缓存服务宕机了，会有大量的请求进来直接打到DB上面。

**解决方案：**事前使用集群缓存，主从+哨兵；事中ehcahe本地缓存+限流+降级；事后开启redis持久化回复。另外，在设置缓存过期时间的时候，我们让他们失效的时间错开。

Redis集群有`16384`个哈希槽`(hash slot)`,每个`key`通过`CRC16`校验后对`16384`取模来决定放置哪个槽.集群的每个节点负责一部分hash slot，查找时候也是这样，至于迁移则将部分槽转移就行。

redis还有什么使用方法，自己理解：redis可以用String数据存储类型对String进行添加等操作，实现计时器，zset延时任务，消息队列，分布式锁。[具体地址](https://juejin.im/post/5caf45b96fb9a0688b573d6c)

使用redis实现分布式锁，set覆盖原值，setnx不覆盖，setex设置超时时间，会出现长生不老、误删等问题，不适合做分布式锁。

